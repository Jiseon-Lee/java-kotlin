JAVA
	자바를 사용하기 위해서는 java.sun.com에서 필요한 jdk를 다운받아 설치해야 함.
		Java SE(Standard Edition) : 자바의 기본적인 기능들로 가장 많이 사용됨
		Java EE(Enterprise Edition) : 기업용/웹용 자바로 가장 많은 기능을 보유하고 있음
		Java ME(Micro Edition) : 작은 전자기기(모바일 포함)에서 작업할 때 사용
	
	1990년대 sunmicrosystem에서 개발한 언어로서 원래는 작은 전자기기 등에 붙여서 동작되는 시스템 프로그램을 위한 언어였으나 PC버전이 발표되어 일반 프로그램에서도 사용하게 됨(후에 oracle에 인수됨)

	최초의 객체지향프로그래(OOP : Object Oriented Programming) 언어이다.
		C언어는 절차지향적 언어로 Java와는 동작순서 및 방식에서 차이가 남

	자바는 컴파일 언어로 개발시간은 느리나, 실행속도는 빠름
		컴파일 언어 : JAVA, C, ASP.Net(C#) 등이 있음
			작업한 파일을 컴파일 단계를 거쳐 컴퓨터가 실행할 수 있는 상태로 만든 후 실행시킴
			컴파일 단계 때문에 개발시간이 더 걸리나 컴파일 후에는 컴퓨터가 빠르게 실행할 수 있음
		인터프리터 언어 : ASP, PHP, Python 등이 있음
			한 줄씩 해석하여 실행시키는 언어로 컴파일 단계가 없어 개발속도가 빠름
			단, 실행할 때 마다 코드를 해석하여 실행시키기 때문에 실행속도는 컴파일 언어에 비해 느림
			Python의 장점은 확장성에 있음(주로 C나 JAVA로 만들어진 모듈을 사용)

	자바는 C언어와 달리 OS에 종속적이지 않아 한 번 입력한 코드는 OS에 상관없이 동작함()
		자바는 JVM(Java Virtual Machine) 위에서 동작하므로 OS의 종류와는 상관없음
		웹에서도 자바를 이용한 JSP, Servlet, JavaBeans 등의 여러 기술을 이용할 수 있음

	자바는 모든 것이 객체(클래스)로 이루어져 있음 : 클래스 외부에 존재하는 것은 없다고 봐도 무방함

	간단한 dos 명령어
		다른 드라이브로 이동 : '드라이브명:'으로 이동
		상위폴더로 이동 : 'cd..'으로 이동
		다른 폴더로 이동 : 'cd 이동하려는 폴더명'으로 이동
		여러 단계의 폴더로 바로 이동하려면 'cd 폴더명1\폴더명2\...\마지막 폴더명'으로 이동

		자바 컴파일 : javac 파일명.java -> 컴파일 명령으로 같은 폴더에 파일명.class 파일이 생성됨 (.java -> 사람이 보기 위한 파일, .class -> 실행파일)
		자바 실행 : java 파일명 -> 프로그램의 실행으로 확장자 없이 파일명(클래스명)만 java명령으로 실행
	
	자바의 주석
		프로그램의 동작에 아무 상관없는 것으로 프로그램에 대한 설명 등을 입력할 수 있음
		// : 한 줄의 주석
		/* */ : 여러 줄 주석
		주석은 많이 입력해 놓는 것이 좋음

	변수(Variable)
		변할 가능성이 조금이라도 있는 값을 저장하기 위한 메모리(RAM - random accass memory 휘발성 메모리) 공간
		필요에 따라 값을 자유롭게 변경할 수 있음
		값의 종류(자료형:data type)에 따라 변수의 크기(용량)도 달라짐(메모리의 효율적인 사용을 위해)
		기본 자료형 8가지만 변수에 저장이 가능 : 다른 자료형은 객체로 취급하여 인스턴스로 작업됨
		문법 : 자료형 변수명[ = 값];		//지정한 자료형에 해당하는 변수를 생성
			변수에 저장하는 값은 변수 선언과 동시에 저장할 수도 있고, 나중에 다른 곳에서 값을 저장할 수도 있음
			단, 될 수 있으면 변수의 초기화(변수에 처음 값을 넣는 행위)는 선언한 곳에서 가까울수록 좋음
		변수는 선언과 동시에 생성이 됨(객체 즉 인스턴스는 선언과 생성을 분리할 수 있음)

	기본 자료형(primitive data type)	8bit = 1byte
		자료형명		크기 및 설명
		boolean		1byte. 논리값으로 참(true), 거짓(false)을 표현하는 자료형(조건으로 많이 사용됨)
		char		2byte. character로 하나의 문자를 표현하는 자료형으로 작은 따옴표로 묶어야 함 - 자바는 유니코드를 사용함
				- 1byte로 한 글자를 표한하는 것은 ANSI코드로 C언어에서 사용함

		byte		1byte. -128~127의 정수표현
		sort		2byte. -32768~32767의 정수표현
		int			4byte. -2147483648~2147483647의 정수를 표현하며, 정수 표현의 기본형으로 사용됨
				- CPU가 4byte 정수를 가장 빠르게 처리할 수 있게 설계되어 있기 때문에 정수 기본형으로 사용(byte나 short보다 int가 처리속도가 빠름)
		long		8byte. -9223372036854775808~9223372036854775807의 정수표현
				- long형을 넘는 정수를 표현하려면 변수가 아닌 클래스(BigInteger)를 이용해야 함

		float		4byte. ±(1.40*10의 -45승 ~ 3.40*10의 38승)의 실수표현
		double		8byte. ±(4.94*10의 -324승 ~ 1.79*10의 308승)의 실수를 표현하며, 실수 표현의 기본형으로 사용됨
				- 실수는 표현의 정확성보다 표현의 범위에 집중하여 실수 연산 시 결과값이 틀리는 경우가 많음
				- 정확한 실수 연산을 하려면 클래스(BigDecimal)를 사용해야 함

	상수(constant)
		변수는 변하는 값을 저장한다면, 상수는 변하지 않는 값을 저장함
		상수는 처음 값을 넣는 최기화에서만 값 지정이 가능하고 그 후에는 절대로 값을 변경할 수 없음
		문법 : final 자료명 상수명;
			변수와 사용법이 동일하나 'final' 키워드로 상수임을 나타냄
			변수와 구분하기 위해 상수의 이름은 대문자로만 입력함
		프로그램 내부에 개발자가 직접 입력하는 값들도 상수로 취급하며 리터럴(literal)값이라고도 함

	자바에서의 이름 규칙
		모든 종류의 이름은 첫 글자를 영문자로 해야함(이름은 영문, 숫자, 언더바(_), 달러($)로만 조합해야 함)
		자바의 키워드(명령어)는 이름으로 사용할 수 없음
		조금 길더라도 의미있는 영문단어를 사용해야 함
		변수, 메소드, 인스턴스 : 첫글자를 영문 소문자로 하고 두 단어 이상의 조합일 경우 두번째 단어부터 각 단어의 첫글자를 대문자로 표기 (예 : memberInfo)
		상수 : 모든 글자를 대문자로 표기하며 두 단어 이상의 조합일 경우 두번째 단어부터 각 단어를 언더바로 연결 (예 : MEMBER_INFO)
		클래스 : 첫글자를 영문 대문자로 하고 두 단어 이상의 조합일 경우 두번째 단어부터 각 단어의 첫글자를 대문자로 표기 (예 : MemberInfo)

	형변환(conversion)
		변수 등이 가지는 자료형을 다른 자료형으로 변환하는 것을 말하며 상황에 따라 변환이 불가능할 수도 있음
		자동 형변환(Implicit Conversion)
			특별히 명령을 내리지 않아도 자동으로 형이 변환되어 사용되는 것을 의미
			보통 작은 자료형이 큰 자료형으로 저장되고, 정수는 실수형 변수에 저장됨
			byte -> short, char -> int -> long -> float -> double
			정수는 실수로 변환이 가능하지만 그 반대는 불가능

		명시적 형변환(Explicit Conversion)
			자동 형변환이 안되는 상황에서 형변환이 필요한 경우 명시적으로 변환을 시키는 명령
			문법 : (변환할 자료형)변환할 값;

	연산자(Operator)
		[], .
		++, --, +expr, -expr, !, (data type)
		*, /, %
		+, -
		<, >, <=, >=, instanceof
		==, !=
		&&
		||
		? expr1 : expr2
		=, +=, -=, *=, /=, &=, |=

		산술연산자 : + - * / %
			숫자(정수, 실수)를 연산하여 결과를 내는 연산자
			피연산자 : 숫자
			결과값 : 숫자
			정수끼리의 연산은 무조건 결과가 정수로 나옴(나눗셈도 포함)
			정수와 실수, 실수와 실수의 연산은 무조건 결과가 실수로 나옴
			% : 나머지 연산자로 나눗셈 후 몫이 아닌 나머지를 구하는 연산자(mod 연산자라고도 함)

		증감연산자 : ++ --
			산술연산자의 일종으로 단항 연산자이며 해당 숫자값을 1씩 증가 또는 감소시키는 연산자

		관계(비교)연산자 : < > <= >= == !=
			두 값을 비교하는 연산자
			피연산자 : - < > <= >= : 숫자, == != : 모든 값
			결과값 : 논리값으로 주로 조건식에서 사용됨

		논리연산자 : && || !
			두 개 이상의 논리값(조건)을 연산하여 하나의 논리값으로 만드는 연산자
			피연산자 : 논리값(조건식), 결과값 : 논리값(true, false)
			&& : 논리곱. AND연산으로 피연산자에 해당하는 조건들이 모두 true여야 결과가 true가 되는 연산자
				 조건들 중 하나라도 false이면 결과가 false가 되는 연산자
			|| : 논리합. OR연산으로 피연산자에 해당하는 조건들이 모두 false여야 결과가 false가 되는 연산자
				 조건들 중 하나라도 true이면 결과가 true가 되는 연산자
			! : 부정. NOT연산으로 피연산자에 해당하는 조건이 true이면 false로 false이면 true로 변환하는 연산자
		
		조건(삼항)연산자 : 조건 ? expr1 : expr2
			피연산자가 유일하게 3개인 연산자로 조건에 따라 처리되는 값이 달라지는 연산자
			문법 : 조건 ? 조건이 참일 경우 처리할 값 : 조건이 거짓일 경우 처리할 값
			if문으로 대체가 가능하므로 사용빈도가 높지 않음
		if (조건) { expr1 } else { expr2 }

		대입 및 복합 연산자 : = += -= *= /= %= &= |=
			연산자들 중 가장 우선순위가 낮은 연산자들로 (계산 후) 값을 변수 등에 대입(저장)하는 연산자
			연산 후 대입하는 복합연산자들은 원래의 식으로 대체할 수도 있음
				예) a += 5 <- 동일 연산 -> a = a + 5
		
		실행흐름의 제어
			기본적으로 프로그램은 위에서 아래로, 왼쪽에서 오른쪽으로 실행되며 이때 그 실행의 흐름을 제어하는 제어문이 존재
			제어문은 크게 분기문과 반복문으로 나눔
			제어문들의 실행문(들)은 중괄호 안에서 입력하지만 실행문이 하나일 경우 중괄호를 생략할 수 있음

		분기문
			조건에 따라 여러 실행문들 중 특정 실행문만을 실행시키는 제어문
			상황에 따라 단 하나의 실행문도 실행되지 않을 수도 있음
			종류로는 if, switch, 조건연산자의 세 가지가 있음

			1. if문
				대표적인 분기문으로 다른 분기문들을 완벽하게 대체할 수 있음
				조건에 따라 필요한 실행문(들)을 실행시킬 수 있음
				문법
					if(조건) {
						조건이 참일 경우 실행할 실행문(들);
					}
					[
					else if (조건2) {
						조건2가 참일 경우 실행할 실행문(들);
					} else if (조건n) {
						조건n이 참일 경우 실행할 실행문(들);
					} ]
					[else {
						모든 조건이 거짓일 경우 실행할 실행문(들);
					}
					]
				else문의 조건은 '아니면'이지만 그 범위가 매우 큰 경우가 많으므로 주의해야 함
				else문이 있으면 반드시 하나의 실행문이 실행되며, 반대로 else문이 없으면 하나도 실행되지 않을 수도 있음
				if문 내부에서 다른 if문을 사용할 수도 있으며(중첩 if문) 내부의 if문은 외부 if의 조건이 참인 상태에서 동작함
				else if문을 사용하면 더 많은 형태의 실행문들을 실행시킬 수 있음
			
			2. 조건연산자
				삼항연산자라고도 하며, 조건에 따라 맞는 시행문을 실행시킴
				단, 실행문은 반드시 하나만 입력해야 하므로 제약이 있어 사용빈도가 if에 비해 낮음
				문법
					조건 ? 참 : 거짓
				조건을 괄호로 묶는 경우가 많은데 필수는 아님

			3. switch문
				if문과 비슷하게 여러 조건을 주어 맞는 특정 실행문(들)을 실행하게 해주는 제어문
				단, 조건을 논리식이 아닌 특정 값 비교로만 사용해야 함
				switch문에서 비교하는 값은 무조건 정수여야 함(실수도 에러남)
				jdk1.7
				if문으로 대체가능하므로 사용빈도가 낮음 (코드가 깔끔해 보이는 장점이 있음)
				문법
					switch(정수) {
						case 정수와 비교할 값1 :
							실행문(들)1;
							break;
						[
						case 정수와 비교할 값2 :		case 비교값 2-1 :		case 비교값2-2 :
						// case의 비교값을 옆으로 여럿 나열하면 조건들을 or로 묶어서 판단해줌
							실행문(들)2;
							break;
						...
						case 정수와 비교할 값2 :
							실행문(들)2;
							break;
						default :
							실행문(들);
						]
					}
				default는 if문의 else와 같이 모든 case가 안맞을 경우 처리할 실행문을 담고 있는 영겨으로 가장 밑에 입력함
				break 명령을 생략하면 해당되는 case의 아랫쪽 모든 실행문들을 다 실행시키므로 보통 break를 사용함

		반복문
			루프(Loop)문이라고도 하며, 조건이 맞는 동안 지정한 실행문을 반복하여 실행시킴
			조건은 대부분 한 번 돌때마다 변하게 되어 있음
				조건이 참에서 변하지 않는 무한루프도 있으나, 웹에서는 사용하지 않고 사용하더라도 반드시 루프문을 빠져나올 방법이 존재해야 함
			종류로는 while, do-while, for, for-each 등이 있음
			특별한 경우가 아니면 반복문 내에서 변수나 객체들을 선언 및 생성하는 걸 줄여야 함
			반복문 내에서 if문을 사용할 경우 else절을 사용할지 여부에 대해 깊이 고민해야 함
			
			1. while문
				조건이 참인 동안 지정한 실행문(들)을 반복하여 실행시키는 반복문
				일반적으로 DB관련 작업시 많이 사용됨
				조건에 따라 한 번도 실행되지 않을 수도 있음
				문법
					while (조건) {
						실행문;
						[조건 변화식;]
					}
			
			2. do-while문
				while문과 비슷하나 조건을 검사하는 위치가 다름
				모든 제어문들 중 유일하게 조건에 상관없이 무조건 처음 한 번은 실행되고, 그 후에 조건을 검사함
				while문처럼 DB관련 작업에서 주로 사용됨
				문법
					do {
						실행문;
						[조건 변화식;]
					} while(조건);
			
			3. for문
				while문 처럼 조건이 참일 동안 동작하며, 내부에서 변수 선언 및 증감이 가능한 반복문
				보통 정해진 횟수가 있는 경우나 배열 또는 컬렉션 등에서 많이 사용됨
				문법
					for (변수 선언 및 초기화[, 다른 변수 선언 및 초기화]; 조건; 증감식[, 다른 증감식]) {
						실행문(들);
					}
				for문 안에서 선언한 변수는 for문 안에서만 사용할 수 있음
				실행순서 : 변수 선언 및 초기화 > 조건 > 실행문 > 증감식 > 조건 > 실행문 > 증감식 > ...
				for문에서 선언하는 변수는 여러 개를 선언할 수 있으며, 증감식도 여러 개를 지정할 수 있음(쉼표로 구분)

			4. for-each문
				배열이나 컬렉션 등을 반복할 경우 사용되는 전용 반복문으로 조건을 따로 입력하지 않음
				배열이나 컬렉션 등에서 사용하면 굉장히 편하나 전체적으로 사용빈도가 높지는 않음
			
			break & continue
				break : 루프문에서 사용할 경우 해당 루프문을 강제로 종료시키고 빠져나옴
				continue : continue명령보다 아래에 있는 명령들을 실행하지 않고 조건절로 감
					조건변화식을 continue보다 아래에 놓으면 무한루프에 빠질 수도 있음

			중첩 루프문
				루프문 안에서 다른 루프문을 사용하는 것으로 세 가지 루프문(while, do-while, for) 모두 엇갈리게 사용할 수도 있음
				주로 2차원 배열에서 많이 사용됨
