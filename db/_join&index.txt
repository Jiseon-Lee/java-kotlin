조인(join)
 - select 쿼리에서 사용하는 기능으로 두 개 이상의 테이블을 서로 묶어서 하나의 결과 집합으로 만들어내는 기능
 - 조인을 사용하면 속도가 느려지지만 조인을 사용하지 않고 처리하려면 더 느려지므로 조인기능을 반드시 숙지해야 함

1. Inner Join
 - 내부 조인이라고도 하며 가장 많이 사용되는 조인으로 일반적으로 조인이라 하면 Inner Join을 의미함
 - 문법
	select 컬럼(들) from 테이블1 inner join 테이블2 on 테이블1과 테이블2의 결합조건
	또는
	select 컬럼(들) from 테이블1, 테이블2 where 테이블1과 테이블2의 결합조건

 - 가져올 컬럼이나 조건 등에서 사용할 컬럼들의 이름이 두 테이블 모두에 있을 수도 있으므로 테이블명.컬럼명의 방식으로 작업해야 하나 테이블명이 길 경우 번거로우므로 alias(별칭)를 붙여 사용하는 것이 일반적임
 - 결합조건은 보통 관계를 맺지 않아도 사용가능하나 일반적으로 관계를 맺은 PK와 FK를 비교하는 것으로 조건을 충족시킴
 - 3개 이상의 테이블 조인
	select 컬럼(들) from 테이블1 inner join 테이블2 on 테이블1과 테이블2의 결합조건 inner join 테이블3 on 테이블3과 테이블1 또는 테이블2의 결합조건
	또는
	select 컬럼(들) from 테이블1, 테이블2, 테이블3 where 테이블1과 테이블2의 결합조건 and 테이블3의 테이블1 또는 테이블2의 결합조건

2. Outer Join
 - 외부 조인이라고도 하며 조인의 조건에 만족하지 않는 레코드들도 포함시키는 조인 방법
 - 문법
	select 컬럼(들) from 테이블1 <left | right> [outer] join 테이블2 on 테이블1과 테이블2의 결합조건

 - left를 사용하면 왼쪽의 테이블인 테이블1의 레코드는 모두 출력하고, 테이블2는 결합조건에 맞는 레코드만 출력
 - right를 사용하면 오른쪽의 테이블인 테이블2의 레코드는 모두 출력하고, 테이블1는 결합조건에 맞는 레코드만 출력
 - outer 명령어는 생략이 가능하여 outer join을 left join이나 right join으로 부르기도 함

3. Cross Join
 - 조건없이 두 테이블의 모든 레코드를 출력하는 조인방법
 - 문법
	select 컬럼(들) from 테이블1 cross join 테이블2
	또는
	select 컬럼(들) from 테이블1, 테이블2
 - 조건이 없으므로 on이나 where절이 따로 필요 없음
 - 실제로는 거의 사용하지 않음

4. Union
 - 조인은 아니고, 두 쿼리의 결과를 합쳐서 하나의 결과물로 출력하는 기능
 - 문법
	select 쿼리1
	union [all]
	select 쿼리2;
 - 사용시 두 쿼리에서 추출하는 컬럼의 개수가 같아야 함(자료형은 달라도 됨)
 - 두 개 이상의 ResultSet이 필요한 상황에서 하나의 ResultSet으로 처리할 수 있게 됨

5. In, Not In 연산자
 - 특정 컬럼의 값이 지정한 목록에 있는지 없는지에 따라 출력할 레코드를 선택하는 기능
 - 문법
	select 컬럼(들) from 테이블 where 컬럼명 in (비교값1, 비교값2, ..., 비교값n);
		-- 컬럼의 값들 중 비교값 목록에 동일한 값이 있을 경우 출력
	select 컬럼(들) from 테이블 where 컬럼명 not in (비교값1, 비교값2, ..., 비교값n);
		-- 컬럼의 값들 중 비교값 목록에 동일한 값이 없을 경우 출력

 - 괄호 안에는 비교할 값들을 쉼표로 구분하여 넣거나 서브쿼리를 이용하여 select할 수 있음
 - 문법(서브쿼리 이용)
	select 컬럼(들) from 테이블 where 컬럼명 in (select 비교할 컬럼 from 테이블 [where 조건]);
		-- 컬럼의 값들 중 서브쿼리로 추출한 값 목록에 동일한 값이 있을 경우 출력
	select 컬럼(들) from 테이블 where 컬럼명 not in (select 비교할 컬럼 from 테이블 [where 조건]);
		-- 컬럼의 값들 중 서브쿼리로 추출한 값 목록에 동일한 값이 없을 경우 출력

※ 서브쿼리
 - 괄호로 묶어서 사용하며 항상 select문으로 서브쿼리를 작성해야 함
 - 사용되는 곳
	select문에서 어디서든 사용가능
	insert문에서는 values 절에서 사용가능
	update문에서는 set 절에서 사용가능
 - join보다도 속도가 느리므로 사용시 주의해야 함

Index
 - 검색속도 향상을 위해 사용하는 기능으로 검색이 이루어지는 특정 컬럼에 장착함

 - 장점
	검색속도가 빨라짐(단, 항상 빨라지는 것은 아님)
	속도가 빨라지므로 쿼리의 실행시간이 줄어들어 전체 시스템(사이트)의 성능이 향상됨

 - 단점
 	인덱스가 DB의 공간을 일정부분 차지하게 되어 DB의 전체 크기가 커짐(일반적으로 DB의 10% 정도 추가 공간이 필요하게 됨)
	처음 인덱스를 생성하는데 시간이 많이 소요될 수 있음
	데이터의 변경 작업(insert, update, delete)이 자주 일어날 경우 오히려 성능이 나빠질 수도 있음
	검색결과가 너무 많이 나오는 컬럼은 인덱스를 장착하는 것이 오히려 느려지게 됨

 - 인덱스는 클러스터 인덱스(clustered index)와 보조 인덱스(secondary index)로 나뉨
	보조 인덱스는 비클러스터 인덱스(non clustered index)라고도 함

 - 클러스터 인덱스는 테이블당 하나만 생성이 가능하며, 보조 인덱스는 여러 개를 생성할 수 있음
 	클러스터 인덱스는 거의 primary key와 동일한 의미로 사용됨(show index from 테이블명 쿼리로 확인 가능)
	기본적으로 테이블의 데이터들은 priimary key로 지정된 컬럼의 값에 따라 오름차순으로 정렬되어 출력됨

 - 보조 인덱스는 특정 컬럼에 unique 제약조건을 걸면 생성됨(여러 개 생성 가능)
 	보조 인덱스가 걸린 컬럼에 not null 제약조건을 추가하면 자동으로 클러스터 인덱스로 지정됨
	단, 정렬은 여전히 primary key를 기준으로 정렬됨
	primary key가 있는 상태에서는 보조 인덱스에 not null을 걸어도 primary key가 우선적으로 클러스터 인덱스로 지정됨

인덱스를 생성하거나 생성하지 않아야 하는 경우
 - where 절에서 조건으로 사용되는 컬럼에는 인덱스를 걸어주는 것이 좋다.
	단, 자주 사용되어야 하며 검색 결과가 적을수록 효과가 높음

 - 데이터의 중복도과 높은 컬럼은 인덱스를 생성해도 큰 효과가 없음

 - 외래키(FK)를 지정한 컬럼에는 인덱스가 자동으로 생성됨

 - join에 자주 사용되는 컬럼에는 인덱스를 생성해 주는 것이 좋음

 - insert/update/delete가 얼마나 자주 일어나는지 고려해야 함
 	자주 일어나면 인덱스를 생성하는 것이 오히려 속도저하를 가져올 수 있음

 - 클러스터 인덱스가 아예 없는 것이 좋은 경우도 있음
 	PK를 지정하지 않고 보조 인덱스에도 not null을 지정하지 않으면 클러스터 인덱스가 없는 상태로 테이블이 생성됨
	insert/update/delete가 자주 일어나는 테이블일 경우 PK가 아예 없는 것이 나을 수도 있음
	예) 쇼핑몰 등에서 이벤트 진행시 값자기 회원이 몰리는 상황
	PK를 일련번호(auto_increment)로 지정하는 경우도 많음 -- 레코드를 구분하기 위해서

인덱스 생성 문법
create index 인덱스명 on 테이블명(인덱스를 장착할 컬럼명);

인덱스 검색 문법
show index from 테이블명;

인덱스 삭제 문법
drop index 인덱스명 on 테이블명;